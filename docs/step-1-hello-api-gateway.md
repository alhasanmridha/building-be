# Step 1: Hello API Gateway (OpenResty + Lua)

This guide describes how to run a minimal **API Gateway** built with **OpenResty**. It exposes a single endpoint:

- `GET /hello` → returns JSON generated by **custom Lua**

The format below is **change → result**, so every action is immediately followed by the expected outcome.

## What gets built

- A Dockerized OpenResty service listening on **`localhost:8080`**
- An Nginx route for **`/hello`** backed by a Lua handler
- A basic **`/healthz`** endpoint for health checks

## Prerequisites

- Docker installed and running
- `make` (optional, but this repo includes a `make run-api-gateway` shortcut)

## 1) Start the gateway

### Change

Run from the repo root:

```bash
make run-api-gateway
```

### Result

- Docker image gets built from `api-gateway/Dockerfile`
- Container starts, and port **8080** becomes reachable on the local machine

Docker commands (equivalent):

```bash
docker build -t api-gateway ./api-gateway
docker run --rm -p 8080:8080 api-gateway
```

## 2) Validate `/hello`

### Change

```bash
curl http://localhost:8080/hello
```

### Result

Response is JSON (example):

```json
{"message":"hello from openresty","service":"api-gateway"}
```

## 3) Validate `/healthz` (optional)

### Change

```bash
curl http://localhost:8080/healthz
```

### Result

```text
ok
```

## 4) OpenResty overview (what it enables)

**OpenResty** is **Nginx** plus the ability to run **Lua** inside Nginx’s request lifecycle (via `ngx_lua` / LuaJIT).

### Result

- Nginx handles HTTP efficiently (routing, keep-alive, connection management)
- Lua lets gateway logic run where needed (auth, rate limiting, request/response shaping, dynamic routing)

In this step, Lua is used for the simplest possible example: “return JSON from `/hello`”.

## 5) Route configuration (`api-gateway/nginx.conf`)

### Change

Key directives:

- `server { listen 8080; }` starts an HTTP server on port 8080
- `location = /hello { ... }` is an **exact match** route for `/hello`
- `content_by_lua_file ...` tells OpenResty: “run this Lua file to generate the response”
- `lua_package_path ...` controls where Lua looks when calling `require(...)`

Here’s the key route:

```nginx
location = /hello {
    default_type application/json;
    content_by_lua_file /etc/nginx/lua/hello.lua;
}
```

### Result

- `GET /hello` is handled by the Lua script located at `/etc/nginx/lua/hello.lua` inside the container
- Response `Content-Type` is set to `application/json`

## 6) Request flow for `GET /hello`

### Result

1) Nginx receives the HTTP request on port **8080**
2) Nginx matches the route: `location = /hello`
3) OpenResty executes the Lua file configured in that route:
   - `content_by_lua_file /etc/nginx/lua/hello.lua;`
4) The Lua handler builds a response payload, JSON-encodes it, and writes it to the response body
5) Nginx returns the response to the client

## 7) Lua handler (`api-gateway/lua/hello.lua`)

### Change

Handler responsibilities:

- Creates a Lua table (like a JSON object)
- Encodes it to JSON (`cjson.safe`)
- Writes it out (`ngx.say`)

### Result

- Application response body is generated by Lua (not a static file)
- Output is written directly into the HTTP response by `ngx.say(...)`

## Files involved

- `api-gateway/nginx.conf`
  - HTTP server + routing rules (`/hello`, `/healthz`)
- `api-gateway/lua/hello.lua`
  - Lua code that generates the `/hello` response
- `api-gateway/Dockerfile`
  - Builds the container image and copies config + Lua into it
- `Makefile`
  - `run-api-gateway` target to build + run locally

## Stop the service

- If running in the foreground: **Ctrl+C**
- Or stop a running container: `docker ps` then `docker stop <id>`

## Exercise (recommended)

1) Change the JSON message in `api-gateway/lua/hello.lua`
2) Re-run `make run-api-gateway`
3) Call `/hello` again and verify the new message is returned

